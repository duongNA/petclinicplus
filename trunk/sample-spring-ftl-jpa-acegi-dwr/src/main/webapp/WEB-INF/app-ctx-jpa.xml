<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
				http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">

	<!-- 
		Configurer that replaces ${...} placeholders with values from a properties file 
		(in this case, JDBC-related settings for the dataSource definition below) 
	-->
	<bean id="propertyConfigurer"
		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="/WEB-INF/jdbc.properties" />
	</bean>


	<!-- 
		Local DataSource that works in any environment.
		Note that DriverManagerDataSource does not pool; it is not intended for production. 
		See JPetStore for an example of using Commons DBCP BasicDataSource as alternative. 
		See Image Database for an example of using C3P0 ComboPooledDataSource as alternative.
	-->
	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driverClassName}" />
		<property name="url" value="${jdbc.url}" />
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
	</bean>

	<!-- 
		JPA EntityManagerFactory 
	-->
	<bean id="entityManagerFactory"
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="dataSource" ref="dataSource" />

		<!-- 
			Loadtime weaving should not be used with Hibernate as it doesn't require any type of instrumentation. 
			See http://opensource.atlassian.com/projects/spring/browse/SPR-2596. 
			<property name="loadTimeWeaver">
			<bean class="org.springframework.instrument.classloading.SimpleLoadTimeWeaver" />
			</property>
		-->
		<property name="jpaVendorAdapter">
			<bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter">
				<property name="database" value="${hibernate.jpa.db}" />
				<property name="databasePlatform" value="${hibernate.dialect}" />
				<property name="showSql" value="true" />
				<property name="generateDdl" value="true" />
			</bean>
		</property>


	</bean>

	<!-- 
		Transaction manager for a single JPA EntityManagerFactory (alternative to JTA) 
	-->
	<bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
		<property name="entityManagerFactory" ref="entityManagerFactory" />
	</bean>


	<!--
		Instruct Spring to retrieve and apply AspectJ aspects (@Aspect) which are defined
		as beans in this context (such as the UsageLogAspect below).
	-->
	<aop:aspectj-autoproxy proxy-target-class="false" />

	<!-- 
		Auto proxy creator that identifies beans to proxy via a list of names. 
		Checks for direct, "xxx*", and "*xxx" matches.
		Note that AspectJ and Spring AOP can be used together.
	-->
	<bean id="autoProxyCreator"
		class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
		<property name="interceptorNames">
			<list>
				<value>methodSecurityInterceptor</value>
			</list>
		</property>
		<property name="beanNames">
			<list>
				<value>clinic</value>
			</list>
		</property>

		<!-- 
			The proxy has already been created. We don't want a proxy to the proxy, so 
			proxyTargetClass is "false".
		-->
		<property name="proxyTargetClass" value="false" />
	</bean>

	<!-- 
		The AspectJ interceptor is named AspectJSecurityInterceptor. Unlike the AOP Alliance security
		interceptor, which relies on the Spring application context to weave in the security interceptor via
		proxying, the AspectJSecurityInterceptor is weaved in via the AspectJ compiler. It would not be
		uncommon to use both types of security interceptors in the same application, with
		AspectJSecurityInterceptor being used for domain object instance security and the AOP Alliance
		MethodSecurityInterceptor being used for services layer security.
	-->
	<bean id="methodSecurityInterceptor"
		class="org.acegisecurity.intercept.method.aopalliance.MethodSecurityInterceptor">

		<!-- 
			When set to true (the default), at startup time the MethodSecurityInterceptor will evaluate if
			the provided configuration attributes are valid. It does this by checking each configuration attribute
			can be processed by either the AccessDecisionManager or the RunAsManager. If neither of these can
			process a given configuration attribute, an exception is thrown.
		-->
		<property name="validateConfigAttributes">
			<value>false</value>
		</property>
		<property name="authenticationManager">
			<ref bean="authenticationManager" />
		</property>
		<property name="accessDecisionManager">
			<bean class="org.acegisecurity.vote.AffirmativeBased">
				<property name="allowIfAllAbstainDecisions" value="false" />
				<property name="decisionVoters">
					<list>
						<bean class="org.acegisecurity.vote.RoleVoter" />
						<bean class="org.acegisecurity.vote.AuthenticatedVoter" />
					</list>
				</property>
			</bean>
		</property>

		<!-- 
			Target methods must be annotated in the interface!
			Annotating the implementation as no effect. 
			Example:
			@Secured({"ROLE_SUPERVISOR" })
			void storeVisit(Visit visit) throws DataAccessException;
		-->
		<property name="objectDefinitionSource">
			<bean class="org.acegisecurity.intercept.method.MethodDefinitionAttributes">
				<property name="attributes">
					<bean class="org.acegisecurity.annotation.SecurityAnnotationAttributes" />
				</property>
			</bean>
		</property>
	</bean>


	<!--
		Simply defining this bean will cause requests to owner names to be saved.
		Spring automatically deploys the @Aspect when AspectJ autoproxying is enabled.
		Note that we can dependency inject this bean like any other bean.
	-->
	<bean id="ownerRequestLogger" class="net.larsbehnke.petclinicplus.aspects.UsageLogAspect">
		<property name="historySize" value="5" />
	</bean>


	<!--
		Instruct Spring to perform declarative transaction management automatically
		on @Transactional annotated classes.
	-->
	<tx:annotation-driven />

	<!--
		PostProcessors to perform resource injection according to the JPA specification
		(@PersistenceContext, @PersistenceUnit).
	-->
	<bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor" />

	<!--
		PostProcessors to perform exception translation on @Repository classes (from native
		exceptions such as JPA PersistenceExceptions to Spring's DataAccessException hierarchy).
	-->
	<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor" />


	<!--
		Will automatically be transactional due to @Transactional (Spring annotation).
		EntityManager will be auto-injected due to @PersistenceContext (JPA annotation).
		PersistenceExceptions will be auto-translated due to @Repository (Spring annotation).
		
		An alternative approach for implementing the service would be extending 
		JpaDaoSupport. JpaDaoSupport relies on on callbacks (just as JdbcDaoSupport)
		and translates exceptions (so PersistenceExceptionTranslationPostProcessor
		would not be necessary). See JpaTemplateClinic in Spring's original PetClinic.
	-->
	<bean id="clinic" class="net.larsbehnke.petclinicplus.jpa.EntityManagerClinic" />


	<!-- 
		Manages the named vocabulary. The default implementation makes use of the ResourceBundle
		to reads its content from a resource file.
	-->
	<bean id="namedVocabularyManager"
		class="net.larsbehnke.petclinicplus.util.namedvocabulary.DefaultNamedVocabularyManager">
	</bean>

	<!-- 
		Populates database with initial values. That is: named vocabulary entries etc.
	-->
	<bean id="dbPopulator" class="net.larsbehnke.petclinicplus.jpa.ClinicDbPopulator">
		<property name="namedVocabularyManager" ref="namedVocabularyManager" />
		<property name="clinic" ref="clinic" />
		<property name="mode" value="INSERT_IF_EMPTY" />
	</bean>



</beans>
